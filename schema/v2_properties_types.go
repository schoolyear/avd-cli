// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"
import "regexp"

// Properties schema for an image layer
type V2PropertiesJson struct {
	// Author corresponds to the JSON schema field "author".
	Author V2PropertiesJsonAuthor `json:"author" yaml:"author" mapstructure:"author"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Network corresponds to the JSON schema field "network".
	Network V2PropertiesJsonNetwork `json:"network" yaml:"network" mapstructure:"network"`

	// Version corresponds to the JSON schema field "version".
	Version V2PropertiesJsonVersion `json:"version" yaml:"version" mapstructure:"version"`
}

type V2PropertiesJsonAuthor struct {
	// Email corresponds to the JSON schema field "email".
	Email string `json:"email" yaml:"email" mapstructure:"email"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *V2PropertiesJsonAuthor) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["email"]; raw != nil && !ok {
		return fmt.Errorf("field email in V2PropertiesJsonAuthor: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in V2PropertiesJsonAuthor: required")
	}
	type Plain V2PropertiesJsonAuthor
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Name) > 100 {
		return fmt.Errorf("field %s length: must be <= %d", "name", 100)
	}
	*j = V2PropertiesJsonAuthor(plain)
	return nil
}

type V2PropertiesJsonNetwork struct {
	// HTTP(s) hosts that are whitelisted in the proxy. Note that the application must
	// be configured to use the proxy or support Windows IE proxy settings
	HttpProxyWhitelist []string `json:"http_proxy_whitelist,omitempty" yaml:"http_proxy_whitelist,omitempty" mapstructure:"http_proxy_whitelist,omitempty"`

	// WhitelistedInternalIps corresponds to the JSON schema field
	// "whitelisted_internal_ips".
	WhitelistedInternalIps []V2PropertiesJsonNetworkWhitelistedInternalIpsElem `json:"whitelisted_internal_ips,omitempty" yaml:"whitelisted_internal_ips,omitempty" mapstructure:"whitelisted_internal_ips,omitempty"`

	// List of IPs or CIDR ranges that are whitelisted for outgoing connections. These
	// should be public IPs
	WhitelistedPublicIps []V2PropertiesJsonNetworkWhitelistedPublicIpsElem `json:"whitelisted_public_ips,omitempty" yaml:"whitelisted_public_ips,omitempty" mapstructure:"whitelisted_public_ips,omitempty"`
}

type V2PropertiesJsonNetworkWhitelistedInternalIpsElem struct {
	// Hostname corresponds to the JSON schema field "hostname".
	Hostname string `json:"hostname" yaml:"hostname" mapstructure:"hostname"`

	// port or port range
	Port *string `json:"port,omitempty" yaml:"port,omitempty" mapstructure:"port,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *V2PropertiesJsonNetworkWhitelistedInternalIpsElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["hostname"]; raw != nil && !ok {
		return fmt.Errorf("field hostname in V2PropertiesJsonNetworkWhitelistedInternalIpsElem: required")
	}
	type Plain V2PropertiesJsonNetworkWhitelistedInternalIpsElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$`, string(plain.Hostname)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Hostname", `^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$`)
	}
	if len(plain.Hostname) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "hostname", 1)
	}
	if len(plain.Hostname) > 63 {
		return fmt.Errorf("field %s length: must be <= %d", "hostname", 63)
	}
	if plain.Port != nil {
		if matched, _ := regexp.MatchString(`^([0-9]{1,5}|[0-9]{1,5}-[0-9]{1,5})$`, string(*plain.Port)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "Port", `^([0-9]{1,5}|[0-9]{1,5}-[0-9]{1,5})$`)
		}
	}
	if plain.Port != nil && len(*plain.Port) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "port", 1)
	}
	if plain.Port != nil && len(*plain.Port) > 11 {
		return fmt.Errorf("field %s length: must be <= %d", "port", 11)
	}
	*j = V2PropertiesJsonNetworkWhitelistedInternalIpsElem(plain)
	return nil
}

type V2PropertiesJsonNetworkWhitelistedPublicIpsElem struct {
	// port or port range
	Port *string `json:"port,omitempty" yaml:"port,omitempty" mapstructure:"port,omitempty"`

	// IP or CIDR range
	Target string `json:"target" yaml:"target" mapstructure:"target"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *V2PropertiesJsonNetworkWhitelistedPublicIpsElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["target"]; raw != nil && !ok {
		return fmt.Errorf("field target in V2PropertiesJsonNetworkWhitelistedPublicIpsElem: required")
	}
	type Plain V2PropertiesJsonNetworkWhitelistedPublicIpsElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Port != nil {
		if matched, _ := regexp.MatchString(`^([0-9]{1,5}|[0-9]{1,5}-[0-9]{1,5})$`, string(*plain.Port)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "Port", `^([0-9]{1,5}|[0-9]{1,5}-[0-9]{1,5})$`)
		}
	}
	if plain.Port != nil && len(*plain.Port) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "port", 1)
	}
	if plain.Port != nil && len(*plain.Port) > 11 {
		return fmt.Errorf("field %s length: must be <= %d", "port", 11)
	}
	*j = V2PropertiesJsonNetworkWhitelistedPublicIpsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *V2PropertiesJsonNetwork) UnmarshalJSON(value []byte) error {
	type Plain V2PropertiesJsonNetwork
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.HttpProxyWhitelist) > 500 {
		return fmt.Errorf("field %s length: must be <= %d", "http_proxy_whitelist", 500)
	}
	if len(plain.WhitelistedInternalIps) > 100 {
		return fmt.Errorf("field %s length: must be <= %d", "whitelisted_internal_ips", 100)
	}
	if len(plain.WhitelistedPublicIps) > 100 {
		return fmt.Errorf("field %s length: must be <= %d", "whitelisted_public_ips", 100)
	}
	*j = V2PropertiesJsonNetwork(plain)
	return nil
}

type V2PropertiesJsonVersion string

const V2PropertiesJsonVersionV2 V2PropertiesJsonVersion = "v2"

var enumValues_V2PropertiesJsonVersion = []interface{}{
	"v2",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *V2PropertiesJsonVersion) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_V2PropertiesJsonVersion {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_V2PropertiesJsonVersion, v)
	}
	*j = V2PropertiesJsonVersion(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *V2PropertiesJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["author"]; raw != nil && !ok {
		return fmt.Errorf("field author in V2PropertiesJson: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in V2PropertiesJson: required")
	}
	if _, ok := raw["network"]; raw != nil && !ok {
		return fmt.Errorf("field network in V2PropertiesJson: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in V2PropertiesJson: required")
	}
	type Plain V2PropertiesJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[a-zA-Z0-9-]+$`, string(plain.Name)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Name", `^[a-zA-Z0-9-]+$`)
	}
	if len(plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	if len(plain.Name) > 25 {
		return fmt.Errorf("field %s length: must be <= %d", "name", 25)
	}
	*j = V2PropertiesJson(plain)
	return nil
}
